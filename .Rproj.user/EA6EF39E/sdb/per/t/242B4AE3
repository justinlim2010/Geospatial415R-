{
    "contents" : "# Function to convert to GeoJSON\ntogeojson <- function(file, projection) {\n  # Required library\n  require(httr)\n  \n  # Send request to ogre.adc4gis.com\n  url <- \"http://ogre.adc4gis.com/convert\"\n  tt <- POST(url, body = list(\n      upload = upload_file(file),\n      sourceSrs = projection,\n      targetSrs = \"EPSG:4326\"\n    )\n  )\n  \n  # Convert request response as text\n  out <- content(tt, as = \"text\")\n}\n\n# Function to convert to SHPfile\ntoshpfile <- function(text) {\n  # Required library\n  require(httr)\n  \n  # Send request to ogre.adc4gis.com\n  url <- \"http://ogre.adc4gis.com/convertJson\"\n  tt <- POST(url, body = list(\n      json = text\n    )\n  )\n  \n  # Convert request response as text\n  out <- content(tt, \"raw\")\n}\n\n# Function to transform GeoJSON projection\ntransformProjection <- function(text, projection) {\n  # Convert geojson to SHPfile as zip\n  zip <- toshpfile(text)\n  \n  # Save SHPFile as zip to temporary directory\n  path <- paste(tempdir(), \"\\\\shp.zip\", sep=\"\")\n  writeBin(zip, path)\n  \n  # Convert SHPfile to geojson while transform the projection\n  togeojson(path, projection)\n}\n\n# Function to calculate Kernel Density\nkde <- function(file, boundary=0) {\n  # Required library and arguments\n  require(maptools)\n  require(GISTools)\n  \n  # read shapefile into r as spatial data frame\n  temp <- tempdir()\n  zip <- unzip(file, list=T)\n  fnameshp <- \"\"\n  for(i in 1:nrow(zip)) {\n    fname <- unzip(file, list=TRUE)$Name[i]\n    unzip(file, files=fname, exdir=temp, overwrite=TRUE)\n    if(grepl(\".shp\", fname)) {\n      fnameshp <- unzip(file, list=TRUE)$Name[i]\n    }\n  }\n  fpath = file.path(temp, fnameshp)\n  ncc_accidentshp <- readShapeSpatial(fpath)\n  unlink(temp)\n  \n  # read boundary shapefile into r as spatial data frame\n  if(boundary != 0)\n  {\n    temp <- tempdir()\n    zip <- unzip(boundary, list=T)\n    fnameshp <- \"\"\n    for(i in 1:nrow(zip)) {\n      fname <- unzip(boundary, list=TRUE)$Name[i]\n      unzip(boundary, files=fname, exdir=temp, overwrite=TRUE)\n      if(grepl(\".shp\", fname)) {\n        fnameshp <- unzip(boundary, list=TRUE)$Name[i]\n      }\n    }\n    fpath = file.path(temp, fnameshp)\n    ncc_sp <- readShapeSpatial(fpath)\n    unlink(temp)\n    \n    nccAcc.den <- kde.points(ncc_accidentshp,lims=ncc_sp)\n    \n    level.plot(nccAcc.den)\n    \n    masker2 <- poly.outer(nccAcc.den,ncc_sp,extend=1000); add.masking(masker2)\n    \n    plot(ncc_sp,add=TRUE, main=\"Kernel Density Estimation\")\n  }\n  else\n  {\n    # Convert from spatial data frame to generic \n    ncc_accident <- as(ncc_accidentshp, \"SpatialPoints\")\n    \n    # Convert the generic sp format into spatstat's pp format\n    ncc_accidentpp <- as(ncc_accident, \"ppp\")\n    \n    # Compute KDE\n    kde_ncc_1000 <- density(ncc_accidentpp,1000)\n    \n    plot(kde_ncc_1000, main=\"Kernel Density Estimation\");\n  }\n}\n\n# Function to calculate L-function\nlfunction <- function(file) {\n  # load maptools library\n  require(maptools)\n  \n  # read shapefile into r as spatial data frame\n  temp <- tempdir()\n  zip <- unzip(file, list=T)\n  fnameshp <- \"\"\n  for(i in 1:nrow(zip)) {\n    fname <- unzip(file, list=TRUE)$Name[i]\n    unzip(file, files=fname, exdir=temp, overwrite=TRUE)\n    if(grepl(\".shp\", fname)) {\n      fnameshp <- unzip(file, list=TRUE)$Name[i]\n    }\n  }\n  fpath = file.path(temp, fnameshp)\n  ncc_accidentshp <- readShapeSpatial(fpath)\n  unlink(temp)\n  \n  # convert from spatial data frame to generic \n  ncc_accident <- as(ncc_accidentshp, \"SpatialPoints\")\n  \n  ncc_accidentpp <- as(ncc_accident, \"ppp\")\n  \n  L <- Lest(ncc_accidentpp)\n  \n  plot(L, main=\"L-Function Envelope\")\n}\n\n\n# Function to calculate NNI\nnni <- function(file, boundary) {\n  # load maptools library\n  require(maptools)\n  require(spatstat)\n  \n  # read shapefile into r as spatial data frame\n  temp <- tempdir()\n  zip <- unzip(file, list=T)\n  fnameshp <- \"\"\n  for(i in 1:nrow(zip)) {\n    fname <- unzip(file, list=TRUE)$Name[i]\n    unzip(file, files=fname, exdir=temp, overwrite=TRUE)\n    if(grepl(\".shp\", fname)) {\n      fnameshp <- unzip(file, list=TRUE)$Name[i]\n    }\n  }\n  fpath = file.path(temp, fnameshp)\n  ncc_accidentshp <- readShapeSpatial(fpath)\n  unlink(temp)\n  \n  # read boundary shapefile into r as spatial data frame\n  temp <- tempdir()\n  zip <- unzip(boundary, list=T)\n  fnameshp <- \"\"\n  for(i in 1:nrow(zip)) {\n    fname <- unzip(boundary, list=TRUE)$Name[i]\n    unzip(boundary, files=fname, exdir=temp, overwrite=TRUE)\n    if(grepl(\".shp\", fname)) {\n      fnameshp <- unzip(boundary, list=TRUE)$Name[i]\n    }\n  }\n  fpath = file.path(temp, fnameshp)\n  ncc_sp <- readShapeSpatial(fpath)\n  unlink(temp)\n  \n  #set window to polygon\n  nccwin <- as.owin(ncc_sp)\n  \n  # convert from spatial data frame to generic \n  ncc_accident <- as(ncc_accidentshp, \"SpatialPoints\")\n  \n  #Convert the generic sp format into spatstat's pp format\n  ncc_accidentpp <- as(ncc_accident, \"ppp\")\n  x <- unmark(ncc_accidentpp)\n  x<-x[nccwin]\n  \n  #compute the NN\n  nnd <- nndist(ncc_accidentpp)\n  hist(nnd)\n  \n  #Compute NNI\n  nni <- nnfun(ncc_accidentpp)\n  x <- nnfun(x)\n  \n  #Compute G test statistics\n  G <- Gest(ncc_accidentpp)\n  plot(G, main=\"NNI G Test Statistic\")\n}\n\n\n",
    "created" : 1396319880039.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "1|41|16|0|\n19|29|32|0|\n109|29|136|0|\n",
    "hash" : "1499225598",
    "id" : "242B4AE3",
    "lastKnownWriteTime" : 1396573345,
    "path" : "D:/R_Project/needForSpeed/R/needForSpeed.R",
    "project_path" : "R/needForSpeed.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}